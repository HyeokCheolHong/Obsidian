# JAVA
1. 프로그래밍 언어와 자바
	컴퓨터가 이해하는 기계어[^machine_language]는 우리가 일상생활에서 사용하는 언어와 다르기 때문에 이해하기가 매우 어렵다.
	그렇기 때문에 컴퓨터와 대화하기 위해서는 사람의 언어와 기계어의 다리 역할을 하는 프로그래밍 언어가 필요하다.
	
	프로그래밍 언어는 고급 언어[^2]와 저급 언어[^3]로 구분된다.\
	고급 언어로 작성된 소스 파일은 컴퓨터가 바로 이해할 수 없기 때문에 컴파일[^compile] 과정을 통해 컴퓨터가 이해할 수 있는 기계어로 변환한 후에 사용해야 한다.


[^machine_language]: 0과 1로 이루어진 이진 코드
[^2]: 컴퓨터와 대화할 수 있도록 만든 언어 중에서 사람이 이해하기 쉬운 언어
[^3]: 기계어에 가까운 언어를 말하며, 대표적으로 어셈블리어가 이에 속한다.
[^compile]: 사람이 이해하는 언어를 0과 1로 이루어진 이진코드로 변환하는 작업
![[Pasted image 20240823025722.png|480]]

2. 자바의 특징
	- 모든 운영체제에서 실행 가능
		 자바로 작성된 프로그램은 ==모든 운영체제에서 실행 가능==하다. 
		 따라서 윈도우에서 개발된 프로그램을 수정없이 바로 맥OS 또는 리눅스에서도 실행할 수 있다는 장점이 있다.
	-  객체지향 프로그래밍
		 먼저 객체(부품)을 만들고, 이 객체들을 서로 연결해서 더 큰 프로그램을 완성시키는 기법을 객체지향 프로그래밍(Object Oriented Programming, OOP)이라고 한다.
		 자바는 OOP를 위한 최적의 언어이다.
	-  메모리 자동 정리
		 메모리(RAM)을 자동 관리하므로, 개발자가 메모리 관리의 수고스러움을 덜고 핵심 기능인 코드 작성에 집중할 수 있다.
	-  풍부한 무료 라이브러리
		 무료로 다운로드 해서 사용할 수 있는 오픈 소스 라이브러리(Open Source Library)가 풍부하기 때문에 프로그램 개발 기간을 단축시켜 준다.



## 바이트코드 파일(클래스 파일)과 자바 가상 머신(JVM)
### 바이트코드 파일(클래스 파일)
- 소스파일(.java)을 작성한 후에는 javac(java compiler) 명령어를 통해 컴파일하여 바이트코드(.class) 파일로 생성된다.
  윈도우, 맥OS, 리눅스 등 어떤 운영체제라 하더라도 동일한 소스 파일을 javac로 컴파일하면 모두 동일한 바이트코드 파일이 생성된다.[^동일한바이트코드생성이유]
	![[Pasted image 20240823032611.png]]

[^동일한바이트코드생성이유]: 자바 가상 머신(JVM)이 운영체제마다 이해하는 기계어로 번역해야 하므로 운영체제 별로 다르게 설치되기 때문, 그래서 운영체제별로 설치하는 JDK가 다른 것이다.

### 자바 가상머신(Java Virtual Machine, JVM)
- 바이트코드 파일(.class)을 특정 운영체제가 이해하는 기계어로 번역하고 실행시키는 명령어는 java 이다.
  java 명령어는 JDK와 함께 설치된 자바 가상 머신을 구동시켜 바이트 코드 파일을 완전한 기계어로 번역하고 실행시킨다.
	![[Pasted image 20240823032655.png|500]]



***



# 변수(Variable)
- 컴퓨터 메모리(RAM)는 수많은 번지들로 구성된 데이터 저장 공간이다.
  프로그램은 데이터를 저장하고 읽는 작업을 빈번히 수행한다. 이때 데이터를 어디에, 어떤 방식으로 저장할지 정해져 있지 않다면 메모리 관리가 무척 어려워진다.
  프로그래밍 언어는 이 문제를 해결하기 위해 변수를 사용한다.
- 변수는 하나의 값을 저장할 수 있는 메모리 번지에 붙여진 이름이다. 변수를 통해 프로그램은 메모리 번지에 값을 저장하고 읽을 수 있다.

>[!info] 
>변수 = "**하나의 값**"을 저장할 수 있는 메모리 번지에 붙여진 이름

## 정수타입 메모리 크기
- 변수의 타입은 해당 변수들이 메모리에 공간을 byte 단위로 얼마만큼 할당할 지를 정한다.
  예로 byte 타입은 1byte로 8bit인데 이를 정수로 변환하면 256이 나온다.
	![[Pasted image 20240823034837.png]]

	![[Pasted image 20240823034945.png]]
	- 각 변수 타입의 최상위 bit(맨 앞의 숫자)는 부호 비트로 사용이 된다.
	  0이면 양수, 1이면 음수이다. 각 양수, 음수의 갯수는 8bit의 최대 정수(256)에서 최상위 비트(음수 0, 양수 1), 0을 제외한 나머지 수를 2로 나누면 된다.
	  그럼 양수, 음수 각각 127개의 수를 가진다.

## 실수 타입
- 실수 타입도 정수타입과 마찬가지로 부호는 최상위 1bit를 가지고 판단하며, 나머지 bit는 '가수'와 '지수'를 저장하기 위한 공간으로 남겨둔다.
  float 유효 소수 자리 : 7자리
  double 유효 소수 자리 : 15자리

	![[Pasted image 20240823040152.png]]
	![[Pasted image 20240823040209.png]]

## 오버플로우(Overflow) / 언더플로우(Underflow)
- 오버플로우 : 타입이 허용하는 최대값을 벗어나는 것
- 언더플로우 : 타입이 허용하는 최소값을 벗어나는 것
- 오버플로우와 언더플로우 모두 허용값을 벗어나게 된다면 각각 반대 부호의 최소값/최대값으로 설정된다.



***



# 객체지향 프로그래밍(Object Oriented Programming, OOP)
- 제품을 만들 때, 부품을 먼저 만들고 조립해서 완성품을 만드는데, 소프트웨어를 개발할 때도 동일하게 객체(부품)을 먼저 만들고 객체들을 하나씩 조립해서 완성된 프로그램을 만드는 기법을 객체지향 프로그래밍이라고 한다.

## 특징
> 캡슐화(Encapsulation)
- 캡슐화란, 객체의 데이터(Field), 동작(Method)을 하나로 묶고 실제 구현 내용을 외부에 감추는 것을 말한다.
- 외부 객체는 객체 내부의 구조를 알지 못하며, 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
  ![[Pasted image 20240824220703.png]]

> 상속(Inheritance)
- 부모 객체는 자기가 가지고 있는 필드와 메소드를 자식 객체에게 물려주어 자식 객체가 사용할 수 있도록 하는데
  이를, Java에서 상속이라고 한다.

> 코드의 재사용성을 높여준다.
- 잘 설계된 부모 객체의 필드와 메소드를 자식 객체가 그대로 사용할 수 있어서 중복 코딩을 하지 않아도 된다.

> 유지보수 시간을 최소화 시켜준다.
- 부모 객체의 필드와 메소드를 수정하면 모든 자식 객체들은 수정된 필드와 메소드를 사용할 수 있다.



***



# 클래스(Class)
> **비유 설명**
- 현실세계에서 자동차를 생성하려면 자동차의 설계도가 필요하듯이, 객체지향 프로그래밍에서도 객체를 생성하려면 ==설계도에 해당하는 클래스==가 필요하다.
  **클래스로부터 생성된 객체**를 해당 클래스의 ==인스턴스(instance)==라고 부르며, 인스턴스 객체를 만드는 과정을 ==인스턴스화==라고 한다.
  동일한 클래스로부터 여러 개의 인스턴스를 만들 수 있는데, 이것은 동일한 설계도로 여러 대의 자동차를 만드는 것과 동일하다.

> **클래스 로더(loader) 동작**

![[Pasted image 20240825004449.png]] ^b7210d

1. **로딩(Locading) 단계** ^8af7e3
	- 클래스 파일을 JVM 메모리로 읽어오는 단계이다.
	- Java 컴파일러는 소스 파일(.java)을 번역하여 바이트코드 파일(.class)을 생성합니다. 이 바이트코드 파일은 로컬 파일 시스템이나 네트워크(외부 라이브러리) 등의 다양한 소스에서 클래스 로더에 의해 메모리로 로드됩니다. 클래스 로더의 로딩 작업은 이 ==바이트코드 파일을 JVM의 메소드 영역에 읽어들여==, 해당 클래스를 런타임에 사용할 수 있도록 준비하는 과정입니다.
2. **링킹(Linking) 단계** ^9ef399
	- 로딩된 클래스를 JVM에 링크하는 단계이다.
		1. 검증(Verification) : 클래스 파일의 구조가 자바 언어 명세와 JVM 명세와 부합하는지 확인
		2. 준비(Preparation) : 클래스의 ==정적 필드(Static Field)와 기본값을 메모리에 할당==합니다.
		3. 해결(Resolution) : 클래스 내부의 심볼릭 레퍼런스를 실제 메모리 주소로 변환합니다.
3. **초기화(Initialization) 단계**
	- 클래스의 정적 초기화 블록(Static Initializer)과 static 필드를 초기화 하는 단계이다.
	- 이 단계에서 클래스의 정적 멤버가 초기화 되며, 필요시 JVM이 자동으로 초기화 순서를 관리한다.


## 객체(Object)
- 객체는 클래스를 기반으로 생성된 실제 인스턴스이다.
  클래스의 속성과 메소드를 가지고 있으며, 메모리에 할당되어 동작한다.
- 객체는 객체지향 프로그래밍의 중요한 개념으로, 물리적으로 전재하거나 개념적인 것 중에서 다른 것과 식별이 가능한 것을 말한다.
  객체는 속성과 동작으로 구성되며, 사람은 이름, 나이 등의 ==속성==과 웃다, 걷다 등의 ==동작==이 있고,
  자동차는 색상, 모델명 등의 ==속성==과 달린다, 멈춘다 등의 ==동작==이 있다.
  Java에선 이러한 ==속성(필드, Field)==와 ==메소드(method)==라고 부른다. ^c7eccc
	![[Pasted image 20240824220515.png]]

### 참조 변수가 객체를 참조하는 방식 이미지
![[Pasted image 20240824221045.png]]



## 필드(Field) or 멤버 변수(Member Variable)
- 객체의 데이터가 저장된 변수를 가리키는 용어
  ex) 클래스 내에 선언된 변수들

### 필드 or 멤버 변수 사용
- 필드를 사용한다는 것은 필드값을 읽고 변경하는 것을 말한다.
- 클래스에서 필드를 선언했다고 해서 바로 사용할 수 있는 것은 아니다.
  필드는 객체의 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않는다.
- 클래스로부터 객체가 생성된 후에 필드를 사용하기 위해서는 객체 외부에서 ==참조 변수와 도트(.) 연산자를 이용해서 필드를 읽고 변경==할 수 있다.
  도트(.) 연산자는 객체 접근 연산자로, 객체가 가지고 있는 필드나 메소드에 접근하고자 할 때 참조 변수 뒤에 붙는다.
  ex) Car라는 클래스를 생성했다고 가정했을 시 
	  Car c = new Car();
	  c.(호출할 필드 or 메소드)



### 인스턴스 멤버(Instance Member) / 정적 멤버(Static Member)
#### 인스턴스 멤버
- 객체에 선언된 변수와 메소드, 생성자 등을 뜻하며, 객체를 선언해야만 사용할 수 있는 멤버를 말한다.
- 여기서 객체에 소속된 멤버에 메소드는 포함되지 않는다.
  메소드는 코드 덩어리이므로 객체마다 저장한다면 중복 저장으로 인해 메모리 효율이 떨어진다.
  따라서, 메소드 코드는 별도의 ==메소드 영역에 두되 공유해서 사용==하고, 이때 ==객체 없이는 사용하지 못하도록 제한을 걸어둔 것==이다.
	![[Pasted image 20240825001154.png]]


#### 정적 멤버
- 정적 멤버란 메소드 영역의 클래스에 고정적으로 위치하는 멤버[^메소드영역의클래스에고정멤버]를 말한다.

[^메소드영역의클래스에고정멤버]: ![[2_JAVA/0_용어#^b7210d]]7210d]]![[2_JAVA/0_용어#^8af7e3]]af7e3]]

> [!INFO] 
> > **메모리 위치**
>    - JVM의 메소드 영역(Method Area)에 저장된다.
>    - 정적 멤버는 JVM이 런타임 시 클래스 정보를 관리하는 메모리 영역이며, 정적 필드(Static Field)는 클래스 로딩 시점에 메소드 영역에 저장되고, 프로그램이 종료될 때까지 유지된다.
>  
> >**사용 방식**
> - 클래스의 객체를 생성할 필요없이 클래스 이름과 도트(.) 연산자를 통해 바로 사용이 가능하다.
  이는 클래스가 로드될 때, 메소드 영역에 정적 멤버로 할당되기 때문에 가능한 것이다.



## 생성자(Constructor)
- new 연산자로 객체를 생성할 때 객체의 초기화 역할
- 선언 형태는 메소드와 비슷하지만, 리턴 타입이 없고 이름을 클래스 이름과 동일하다.



## 메소드(Method)
- 객체가 수행할 동작이다.
- 다른 프로그램 언어에서는 함수라고 하기도 하는데, 객체 내부의 함수는 메소드라고 부른다.
- 메소드는 객체와 객체 간의 상호작용을 위해 호출한다.



## 오버로딩(Overloading) / 오버라이딩(Overriding)
### 오버로딩
- 생성자나 메소드의 다형성을 위해 같은 이름의 기능들이 여러 동작을 하도록 구현하는 것

> 오버로딩 조건
- 매개변수의 타입, 개수, 위치가 다르면 오버로딩 된다.


### 오버라이딩
- 부모 클래스로부터 상속받은 필드나 메소드에 대한 기능을 재정의하는 것
  상속받은 기능의 그대로를 쓰기 위해서는 생성자는 super(), 메소드는 super.[메소드명] 을 쓰면 된다.



***



# 다형성(Polymorphism)
- 다형성이란, 사용 방법은 동일하지만 실행 결과가 다양하게 나오는 성질을 말한다.
  자동차의 부품을 교환하면 성능이 다르게 나오듯이 프로그램을 구성하는 객체(부품)를 바꾸면 프로그램의 실행 성능이 다르게 나올 수 있다.
  자동차에 어떤 타이어를 장착하느냐에 따라서 주행 성능이 달라진다(다형성)

> **다형성 예시**
- 한국 타이어와 금호 타이어는 타이어를 상속하고 있다. 때문에 타이어(부모)의 메소드를 오버라이딩 하고 있다면, 타이어 메소드 호출 시 오버라이딩 된 메소드가 호출된다.
- 오버라이딩 된 내용은 한국 타이어, 금호 타이어 두 타이어 모두 다르기 때문에 실행결과가 다르게 나온다. 이것을 다형성이라고 한다.

## 매개변수 다형성
- 메소드가 클래스 타입의 매개변수를 가지고 있을 경우, 호출할 때 동일한 타입의 객체를 제공하는 것이 정석이지만 업캐스팅 된 자식 객체를 제공할 수도 있다.

```java
public class Driver {
	public void drive(Vehicle vehicle) {
		vehicle.run();
	}
}
```

![[Pasted image 20240825150628.png]]
- drive() 메소드는 매개변수 vehicle이 참조하는 객체의 run() 메소드를 호출하는데, 자식 객체가 run() 메소드를 재정의하고 있다면 재정의된 run() 메소드가 호출된다.
- 그러므로 어떤 자식 객체가 제공되느냐에 따라서 drive()의 실행결과가 달라지는데 이것을 매개변수의 다형성이라고 한다.

## 다형성에서 메소드 호출 과정

> **메소드 호출 과정 예시 코드**

```java
class Parent {
    void show() {
        System.out.println("Parent's show()");
    }
}

class Child extends Parent {
    @Override
    void show() {
        System.out.println("Child's show()");
    }
}

public class TestDynamicDispatch {
    public static void main(String[] args) {
        Parent obj = new Child(); // Parent 타입 참조변수, Child 객체 참조
        obj.show(); // 동적 디스패치 발생
    }
}
```


> **컴파일 (정적 바인딩)**
- 컴파일 시점에는 ==**정적 바인딩(Static Binding)**==이 일어납니다.
- 이 시점에서 컴파일러는 다음과 같은 작업을 수행합니다
	1. **메소드 존재 여부 확인** : 컴파일러는 참조 변수가 선언된 타입(예: 인터페이스 또는 부모 클래스)에 해당 메소드가 존재하는지 확인합니다.  이때 메소드가 존재하지 않으면 컴파일 에러가 발생합니다.
		- 예를 들어, `Parent obj = new Child();`라는 코드에서`obj.show();`를 호출할 때, 컴파일러는 `Parent` 클래스에 `show()` 메소드가 정의되어 있는지 확인합니다.
		- 만약, `Parent` 클래스에 `show()` 메소드가 없다면 컴파일 에러가 발생합니다.
	   
    2. **메소드 시그니처 확인** : 호출하려는 메소드의 이름, 매개변수 타입, 개수 등이 참조 변수의 타입과 일치하는지 확인합니다. 이는 ==**메소드 호출이 컴파일러에 의해 승인되기 위한 단계**==입니다.

    3. **참조 타입을 기준으로 메소드 호출 가능 여부** : 컴파일러는 참조 변수의 타입(예: `Parent`)을 기준으로, 메소드 호출이 가능한지 확인합니다. 하지만, 이 시점에서 어떤 메소드가 실제로 호출될 것인지는 결정되지 않습니다.
       즉, ==**컴파일러는 메소드 호출이 가능한지만 체크**==할 뿐, 실제 메소드 호출은 런타임에서 결정됩니다.


> **런타임 (동적 바인딩 or 동적 디스패치 or 런타임 다형성)**
- 런타임 시점에는 동적 디스패치(Dynamic Dispatch)가 발생합니다.
- 이 과정에서 JVM은 참조 변수가 가리키는 실제 객체의 타입을 기준으로 호출할 메소드를 결정합니다.
	1. **참조 변수의 실제 객체 타입 확인** : 런타임에 JVM은 참조 변수가 가리키고 있는 객체의 타입을 확인합니다.
		- 예를 들어, `Parent obj = new Child();`에서 `obj`는 `Parent` 타입으로 선언되었지만, 실제로는 Heap 영역에 생성된 객체가 `Child` 객체입니다.
		  이때, JVM은 `obj`가 가리키는 객체의 실제 타입이 `Child`임을 인식합니다.

	2. **메소드 디스패치 테이블을 통한 메소드 호출** : JVM은 해당 객체(`Child` 클래스)의 메소드 디스패치 테이블(vtable)을 확인하여 호출할 메소드의 주소를 찾는다.
		- 메소드 디스패치 테이블은 각 클래스가 자신이 가지고 있는 메소드들의 정보를 저장하는 구조입니다.
		  이 테이블에는 해당 클래스에 존재하는 메소드의 주소가 저장되어 있으며,  ==**상속받은 메소드가 오버라이딩 된 경우, 부모 클래스의 디스패치 테이블에 메소드 주소가 자식 클래스의 메소드로 덮어씌여집니다.**==
	
	3. **오버라이딩 된 메소드 선택** : JVM은 객체의 실제 타입(예: `Child`)에서 메소드의 주소로 접근하여 그 메소드가 오버라이딩 되어 있다면 그 메소드를 호출합니다. 
	   만약 오버라이딩 된 메소드가 없다면 부모 클래스의 메소드를 호출합니다. 이 과정에서 JVM은 가상 디스패치 테이블(vtable)을 통해 메소드의 주소를 빠르게 찾을 수 있습니다.



***



# 상속(Inheritance)
- 클래스를 재사용해서 새로운 클래스를 만들기 때문에 중복되는 코드를 줄여 개발 시간을 단축 시킨다.

## 타입 변환(Casting)
- 클래스에서의 타입변환은 상속 관계에 있는 클래스 사이에서 발생한다.

### 업캐스팅 or 자동 타입 변환(Promotion)
- 자동적으로 타입 변환이 일어나는 것을 말한다.

> **자동 타입 변환 예제 코드**
- 아래 cat과 animal 변수는 타입만 다를 뿐, Cat 객체는 부모 타입인 Animal을 포함하고 있기 때문에 동일한 Cat 객체를 참조한다.
	![[Pasted image 20240825135112.png]]

```java
Cat cat = new Cat();
Animal animal = cat;
```

### 다운캐스팅 or 강제 타입 변환(Casting)

> **강제 타입 변환 예제 코드**
- 자식 타입은 부모 타입으로 자동 변환되지만, 반대로 부모 타입은 자식타입으로 자동 변환되지 않는다.
  이유는, 자식 타입이 상속받은 속성과 메소드를 포함하여 자식 속성과 메소드도 가지고 있기 때문에 부모 타입에겐 없는 속성과 메소드도 있기 때문이다.
- 자식 객체가 부모타입으로 자동변환하면 부모 타입의 속성과 메소드만 사용 가능하다는 제약사항이 따른다.
  하지만, 자식 타입의 속성과 메소드를 사용해야 한다면 강제 타입 변환을 통해 다시 자식 타입으로 변환해야 한다.
  
```java
Animal animal = new Cat();  // 자동 타입 변환(업캐스팅)
Cat cat = (Cat) animal;     // 강제 타입 변환
```



*** 



# 추상 클래스(abstract)
- 객체를 생성할 수 있는 클래스를 실체 클래스라고 한다면, 추상 클래스는 공통적인 필드나 메소드를 추출해서 선언한 클래스를 말한다.
- 추상 클래스는 새로운 실체 클래스를 만들기 위한 부모 클래스로만 사용된다.
  따라서, 실체 클래스는 추상 클래스를 상속해서 공통적인 필드나 메소드를 물려받을 수 있다.
	

> **추상 클래스 예시**
- 예를 들어 Bird, Insert, Fish와 같은 실체 클래스에서 공통되는 필드와 메소드를 따로 선언한 Animal 클래스를 만들 수 있고, 이것을 상속해서 실체 클래스를 만들 수 있다.
- 추상 클래스는 실체 클래스의 공통되는 필드와 메소드만 추출해서 만들기 때문에 new 연산자를 사용해서 객체를 직접 생성할 수 없다.
	![[Pasted image 20240825192323.png]]

# 추상 메소드
- 자식 클래스들이 가지고 있는 공통 메소드를 뽑아내어 추상 클래스로 작성할 때, 메소드 선언부만 동일하고 실행 내용은 자식 클래스마다 달라야 하는 경우가 많다.
  예를 들어, 동물은 소리를 내기 때문에 Animal 추상 클래스에 sound() 메소드를 선언할 수 있지만, 실행 내용은 동물마다 다르기 때문에 추상 클래스에서 통일하게 작성할 수 없다.
  그렇기 때문에 추상 클래스에서 추상 메소드를 만들어서 자식 클래스에서 무조건 오버라이딩을 진행시키도록 하여 동물마다 각기 다른 소리를 내도록 유도할 수 있다.
- 이런 추상 메소드는 자식 클래스에서 ==무조건== 오버라이딩을 진행해야 한다. 하지 않으면 에러가 발생
	![[Pasted image 20240825203056.png]]



***


# 인터페이스(Interface)
- 자식 클래스가 여러 부모 클래스를 상속받을 수 있다면, 다양한 동작을 수행할 수 있다는 장점을 가지게 될 것입니다.
  하지만 클래스를 이용하여 다중 상속을 할 경우 메소드 출처의 모호성 등 여러 가지 문제가 발생할 수 있어, 자바에서는 클래스를 통한 다중 상속은 지원하지 않습니다.
- 하지만 다중 상속의 이점을 버릴 수 없기에 자바에서는 ==인터페이스라는 것을 통해 다중 상속을 지원==하고 있다.
  인터페이스란 다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지 담당하는 일종의 추상 클래스를 의미한다.
- 추상 클래스는 추상 메소드 뿐만 아니라 생성자, 필드, 일반 메소드도 포함할 수 있지만
  인터페이스는 오로지 ==추상 메소드와 정적 상수==만을 포함할 수 있습니다.

> **Java 인터페이스 특징**
- 하나 이상의 부모로부터 다중 상속이 가능하다.
- public static final로 인식되는 정적 상수만 올 수 있다.
- public abstract로 인식되는 추상 메소드만 정의할 수 있다. (일반 메소드 정의 불가)
- 자식 클래스에서 implements 키워드를 통해 구현한다.
  상속받은 자식 클래스에서 부모 인터페이스의 추상 메소드를 반드시 오버라이딩 해야한다.
- 인터페이스는 객체 생성을 하지 못한다.
- 인터페이스끼리의 상속은 extends 키워드를 사용한다.



***



# 봉인된 클래스(sealed class)
- Java 15버전 이상부터 지원하는 기능으로, 무분별한 자식 클래스 생성을 방지하기 위해 봉인된 클래스가 도입되었다.

> **문법 예시**
- Person의 자식 클래스로 Employee와 Manager만 가능하고, 그 이외는 자식 클래스가 될 수 없도록 봉인된 클래스로 선언할 수 있다.

```java 
public sealed class Person permits Employee, Manager {
	...
}
```

>[!warning]
> permits 키워드로 지정된 자식 클래스들은 상속받으면 부모와 마찬가지로 sealed 키워드를 붙여줘야 함
> 부모 클래스와는 다르게 자식 클래스는 상속에 제한을 둘 것이 아니라면 non-sealed 키워드를 붙여주면 됨



***



# 싱글톤 패턴(Singleton Pattern)
- 애플리케이션 전체에서 단 한 개의 객체만 생성해서 사용하고 싶을 때 싱글톤 패턴을 사용하면 된다.
- 싱글톤 패턴의 핵심은 생성자를 private로 접근 제한시켜 외부에서 new 연산자로 객체를 호출하지 못하도록 막는 것이다.
  생성자를 호출할 수 없으니 외부에서 마음대로 객체를 생성하는 것이 불가능하기 때문에, 싱글톤 패턴이 제공하는 정적 메소드를 통해 간접적으로 객체를 얻을 수 있다.
	![[Pasted image 20240825015404.png]]



***


# DTO(Data Transfer Object)

![[Pasted image 20240823001949.png | 400]] 

- DTO는 순수하게 데이터를 담아 계층 간으로 '한 번에' 전달하는 객체이다.
- 로직을 갖지 않고, 순수히 데이터를 '전달'하는 용도로만 사용하기 때문에 getter/setter 메소드 외에는 불필요하다. ^DTO

> **사용 사례**
- 웹 애플리케이션에서 클라이언트로부터 받은 데이터를 서버에서 처리하기 위해 DTO로 변환
  여러 개의 데이터를 여러 번 보내면 서버비용이 많이 발생하기 때문에 DTO에 담아서 한 번에 보내는 듯함 ^2ff344

> **데이터 불변성**
* 계층 간 데이터를 전송하기 전에는 setter 메소드를 이용하여, 전송받을 때는 getter 메소드를 이용하는 것을 데이터의 변조가 가능하다고 하여 ==가변== 이라고 한다.
* 또, 데이터를 전송할 때 데이터의 변조가 일어나는 것을 막고 싶을 때는 값의 설정을 생성자를 통해서만 설정하도록 하고, 
  getter 메소드로 값을 전송받으면 데이터의 변조가 불가능하다고 하여  ==불가변== 이라고 한다.



# VO(Value Object)
- VO는 고유한 값이나 상태를 표현하는 객체
- 주로 특정 비즈니스 도메인에서 의미있는 값을 표현할 때 사용
- VO 클래스로 2개의 객체화를 진행했을 때, 두 객체가 참조하는 주소를 비교하는 것이 아닌 두 객체가 가지고 있는 값이 서로 동등한 지를 비교한다는 의미로 이해했다. (맞는지는 몰겠음)

> **사용 사례**
- 금액, 날짜, 좌표와 같이 특정 도메인에서 중요한 값을 표현할 때
- 동일한 데이터를 가진 두 객체를 비교할 때 그 값이 동일한지 확인하고자 할 때

> **데이터 불변성**
- 객체의 값을 표현하고 그 값을 ===불변(immutable)===으로 유지하는데 사용하며, VO는 상태 변경없이 값의 동등성을 비교
- 객체가 생성된 후에 그 상태를 변경할 수 없다. (Stack 영역의 변수에 주소값을 변경할 수 없다는 뜻인 듯)

> **예시 코드**
```java
public final class Money {
    private final int amount;
    private final String currency;

    public Money(int amount, String currency) {
        this.amount = amount;
        this.currency = currency;
    }

    public int getAmount() {
        return amount;
    }

    public String getCurrency() {
        return currency;
    }

    // equals and hashCode override for value comparison
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Money money = (Money) o;
        return amount == money.amount && currency.equals(money.currency);
    }

    @Override
    public int hashCode() {
        return Objects.hash(amount, currency);
    }
}
```



# DTO와 VO의 차이점 요약
> **목적**
- DTO : 데이터를 전송하기 위한 객체이고, 비즈니스 로직이 없으며 데이터의 변경이 가능하다.
- VO : 특정 값을 표현하기 위한 객체로, 불변성을 가지고 비즈니스 로직이 포함될 수 있습니다.

> **불변성**
- DTO : 가변(mutable)한 객체 (변경 가능)
- VO : 불변(immutable) 객체 (변경 불가능)

> **사용 시점**
- DTO : 주로 데이터 전송 계층에서 사용
- VO : 도메인 모델이나 비즈니스 로직에서 중요한 값을 나타낼 때 사용



***




